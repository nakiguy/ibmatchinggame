<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Infoblox Threat Actor Match</title>

  <!-- iPad/Safari app-like behavior -->
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <!-- Use Infoblox Black for OS chrome on mobile -->
  <meta name="theme-color" content="#101820" />

  <!-- Lato (temporary external fallback until Alliance is licensed/hosted) -->
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;600;700;900&display=swap" rel="stylesheet">

  <style>
    :root {
      /* Infoblox brand palette */
      --ib-black: #101820;
      --ib-green: #00BD4D;
      --ib-offwhite: #F0EFE9;
      --ib-teal: #00E2EC;    /* sparing accent only */
      --ib-yellow: #FEDD00;  /* sparing accent only */
      --ib-steel: #D9E1E2;

      /* Tertiary accent used for error/negative */
      --ib-coral: #FF585D;

      /* Primary gradient (use once per page, on dark backgrounds) */
      --ib-gradient: linear-gradient(90deg, #FEDD00 0%, #00BD4D 65%, #00E2EC 100%);

      /* Map existing variables to brand */
      --blox-blue: var(--ib-green);         /* primary CTA color now Infoblox Green */
      --blox-dark: var(--ib-black);         /* base dark */
      --blox-gray: var(--ib-steel);         /* neutral border/background tint */
      --blox-green: var(--ib-green);        /* success/positive */
      --blox-red: var(--ib-coral);          /* error/negative */
      --blox-bg: var(--ib-black);           /* page background is Infoblox Black */
      --radius: 16px;
    }

    html, body {
      margin: 0;
      height: 100%;
      background: var(--blox-bg);
      color: #FFFFFF; /* text on dark background */
      font-family: "Lato", system-ui, -apple-system, "Segoe UI", Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      -webkit-tap-highlight-color: transparent;
    }

    .wrap {
      max-width: 1100px;
      margin: 0 auto;
      padding: 16px 20px 32px;
    }

    header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 16px;
      margin: 8px 0 16px;
      flex-wrap: wrap;
    }

    .brand {
      display: flex;
      align-items: center;
      gap: 12px;
      min-height: 40px;
    }

    .brand-logo {
      width: 160px;
      height: 40px;
      object-fit: contain;
      display: block;
    }

    h1 {
      font-family: "Lato", system-ui, -apple-system, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      font-size: 24px;
      line-height: 1.2;
      margin: 0;
      letter-spacing: 0;           /* Tracking: 0 */
      text-transform: uppercase;   /* Headlines in ALL CAPS when short */
    }

    /* Gradient headline highlight (only on dark background; single use) */
    .headline--highlight {
      background: var(--ib-gradient);
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
    }

    .controls {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }

    button {
      appearance: none;
      border: 0;
      border-radius: 999px;
      padding: 12px 18px;
      font-size: 16px;
      background: var(--blox-blue); /* Infoblox Green */
      color: #FFFFFF;
      font-weight: 700;             /* CTA buttons bold */
      text-transform: uppercase;    /* CTA buttons in ALL CAPS */
      box-shadow: 0 6px 16px rgba(0, 189, 77, 0.25); /* green glow */
    }

    button.secondary {
      background: transparent;      /* on dark, keep secondary minimal */
      color: #FFFFFF;
      border: 2px solid var(--blox-gray);
      box-shadow: none;
    }

    button:active { transform: translateY(1px); }

    .grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 16px;
    }

    @media (min-width: 900px) {
      .grid {
        grid-template-columns: 1fr 1fr;
        gap: 22px;
      }
    }

    .panel {
      background: #FFFFFF;          /* white panels over black bg for readability */
      border: 1px solid var(--blox-gray);
      border-radius: var(--radius);
      padding: 16px;
      min-height: 220px;
      color: var(--blox-dark);      /* dark text inside white panel */
    }

    .panel h2 {
      font-family: "Lato", system-ui, -apple-system, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      font-size: 18px;
      margin: 0 0 12px;
      letter-spacing: 0;
      text-transform: none;         /* subheads typically sentence case */
      font-weight: 600;             /* SemiBold */
    }

    .list, .slots {
      display: grid;
      gap: 12px;
    }

    /* Cards (descriptions) and slots (actors) */
    .card, .slot {
      border: 2px solid var(--blox-gray);
      background: #FFFFFF;
      border-radius: 12px;
      padding: 14px;
      font-size: 16px;
    }

    .card {
      box-shadow: 0 3px 10px rgba(2, 6, 23, 0.06);
      color: var(--blox-dark) !important; /* ensure visible text on buttons */
      text-align: left;
      touch-action: none; /* smoother pointer drag on touch */
      user-select: none;
      -webkit-user-select: none;
      font-family: "Lato", system-ui, -apple-system, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      font-weight: 400;             /* body Regular */
      line-height: 1.2;             /* ~120% leading */
    }

    .card[aria-selected="true"] {
      outline: 3px solid var(--blox-blue);
      border-color: var(--blox-blue);
    }

    .card.assigned-card {
      opacity: 0.6;
    }

    .slot {
      min-height: 96px;
      display: grid;
      align-items: start;
      gap: 10px;
      padding-top: 6px;
    }

    .slot .top {
      display: flex;
      align-items: center;
      gap: 12px;
      min-height: 56px;
    }

    /* SVGs or PNGs both work here */
    .actor-photo {
      width: 56px;
      height: 56px;
      border-radius: 10px;
      object-fit: cover;
      background: var(--ib-offwhite);
      border: 1px solid var(--blox-gray);
      flex: 0 0 auto;
    }

    .label {
      font-family: "Lato", system-ui, -apple-system, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      font-size: 16px;
      font-weight: 700;
      color: #1F2937;
    }

    .assigned {
      background: #F1F5F9;
      border-radius: 10px;
      padding: 10px;
      font-size: 15px;
      color: #111827;
    }

    .slot.correct { border-color: var(--blox-green); }   /* Infoblox Green */
    .slot.incorrect { border-color: var(--blox-red); }   /* Infoblox Coral */

    /* Drop target highlight */
    .slot.drop-target {
      border-color: var(--blox-blue);
      box-shadow: 0 0 0 3px rgba(0, 189, 77, 0.15) inset;
    }

    .hint {
      margin-top: 10px;
      color: var(--ib-steel); /* readable hint on dark header */
      font-size: 14px;
      min-height: 22px;
    }

    .toast {
      position: fixed;
      left: 50%;
      bottom: 22px;
      transform: translateX(-50%);
      background: #111827;
      color: #FFFFFF;
      padding: 12px 16px;
      border-radius: 12px;
      font-size: 15px;
      box-shadow: 0 8px 18px rgba(2, 6, 23, 0.35);
      opacity: 0;
      pointer-events: none;
      transition: opacity .2s ease;
      z-index: 10000;
    }
    .toast.show { opacity: 1; }

    .success {
      display: none;
      margin-top: 12px;
      background: #ECFDF5;
      color: #065F46;
      border: 1px solid #A7F3D0;
      padding: 14px;
      border-radius: 12px;
      font-weight: 600;
    }

    .footer {
      margin-top: 14px;
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="brand">
        <img id="brandLogo" class="brand-logo" alt="Infoblox logo" />
        <div>
          <h1 class="headline headline--highlight">Threat Actor Match</h1>
          <div class="hint" id="hint">Match each description to the correct actor, then tap “Check Answers”.</div>
        </div>
      </div>
      <div class="controls">
        <button class="secondary" id="resetBtn" aria-label="Reset game">Reset</button>
        <button id="checkBtn" aria-label="Check answers">Check Answers</button>
      </div>
    </header>

    <div class="grid">
      <section class="panel" aria-labelledby="descTitle">
        <h2 id="descTitle">Descriptions</h2>
        <div class="list" id="descList" role="list"></div>
      </section>

      <section class="panel" aria-labelledby="actorTitle">
        <h2 id="actorTitle">Actors</h2>
        <div class="slots" id="slots" role="list"></div>
        <div class="success" id="successMsg">Perfect! You matched them all correctly.</div>
        <div class="footer">
          <button class="secondary" id="tryAgainBtn" aria-label="Try again" style="display:none;">Try Again</button>
        </div>
      </section>
    </div>
  </div>

  <div class="toast" id="toast" role="status" aria-live="polite"></div>

  <script>
    // 0) CONFIG: path to your Infoblox logo (SVG or PNG)
    var LOGO_SRC = 'infoblox_Logo_White_RGB.svg';

    // 1) CONTENT: you can use SVGs or PNGs for img fields below
    var PAIRS = [
      { actor: "VexTrio Viper", img: "viper.svg", description: "A large criminal enterprise using TDS, lookalike domains and RDGAs to deliver malware and scams at scale." },
      { actor: "Savvy Seahorse", img: "savvy-seahorse.svg", description: "A persistent investment fraud actor that uses DNS CNAME records as a TDS, often via social media ads." },
      { actor: "Loopy Lizard", img: "loopy-lizard.svg", description: "A phishing actor that creates lookalike domains for banks and government services to steal credentials." },
      { actor: "Decoy Dog", img: "decoy-dog.svg", description: "A DNS C2 malware toolkit, discovered via DNS logs and used by multiple actors for command and control." },
      { actor: "Revolver Rabbit", img: "revolver-rabbit.svg", description: "An actor associated with rotating domain infrastructure and short-lived campaigns leveraging DNS for redirection." }
    ];

    // 2) SHUFFLE helper
    function shuffle(arr) {
      var a = arr.slice();
      for (var i = a.length - 1; i > 0; i--) {
        var j = Math.floor(Math.random() * (i + 1));
        var tmp = a[i];
        a[i] = a[j];
        a[j] = tmp;
      }
      return a;
    }

    // 3) Pointer coordinate helper (compatible with older Safari)
    function getPoint(e) {
      if (typeof e.clientX === 'number' && typeof e.clientY === 'number') {
        return { x: e.clientX, y: e.clientY };
      }
      var t = (e.touches && e.touches[0]) || (e.changedTouches && e.changedTouches[0]);
      return t ? { x: t.clientX, y: t.clientY } : { x: 0, y: 0 };
    }

    // 4) STATE
    var assignments = new Map(); // actor -> description text
    var selectedDescId = null;
    var shuffledDescs = [];
    var shuffledActors = [];

    var brandLogo = document.getElementById('brandLogo');
    var descList = document.getElementById('descList');
    var slotsEl = document.getElementById('slots');
    var toast = document.getElementById('toast');
    var successMsg = document.getElementById('successMsg');
    var tryAgainBtn = document.getElementById('tryAgainBtn');
    var checkBtn = document.getElementById('checkBtn');
    var resetBtn = document.getElementById('resetBtn');
    var hint = document.getElementById('hint');

    function init() {
      // set logo
      brandLogo.src = LOGO_SRC;
      brandLogo.onerror = function() { brandLogo.style.display = 'none'; };

      assignments.clear();
      successMsg.style.display = 'none';
      tryAgainBtn.style.display = 'none';
      hint.textContent = 'Match each description to the correct actor, then tap “Check Answers”.';

      shuffledActors = shuffle(PAIRS);
      shuffledDescs = shuffle(PAIRS);

      renderDescriptions();
      renderSlots();
    }

    function renderDescriptions() {
      descList.innerHTML = '';
      for (var i = 0; i < shuffledDescs.length; i++) {
        var pair = shuffledDescs[i];
        var values = Array.from(assignments.values());
        var isAssigned = values.indexOf(pair.description) !== -1;

        var card = document.createElement('button');
        card.className = 'card' + (isAssigned ? ' assigned-card' : '');
        card.type = 'button';
        card.role = 'listitem';
        card.id = 'desc-' + i;
        card.setAttribute('aria-selected', String(selectedDescId === card.id));
        card.textContent = pair.description;

        // Tap-to-select (fallback and quick assignment)
        card.addEventListener('click', (function(cId) {
          return function() {
            selectedDescId = (selectedDescId === cId) ? null : cId;
            updateSelectionStyles();
          };
        })(card.id));

        // Drag-and-drop
        attachDragHandlers(card, pair.description);

        descList.appendChild(card);
      }
    }

    function updateSelectionStyles() {
      var cards = descList.querySelectorAll('.card');
      for (var i = 0; i < cards.length; i++) {
        var el = cards[i];
        el.setAttribute('aria-selected', String(el.id === selectedDescId));
      }
    }

    function renderSlots() {
      slotsEl.innerHTML = '';
      for (var i = 0; i < shuffledActors.length; i++) {
        var pair = shuffledActors[i];

        var slot = document.createElement('div');
        slot.className = 'slot';
        slot.role = 'listitem';
        slot.dataset.actor = pair.actor;

        var top = document.createElement('div');
        top.className = 'top';

        var img = document.createElement('img');
        img.className = 'actor-photo';
        img.src = pair.img || '';
        img.alt = pair.actor + ' image';
        img.loading = 'lazy';
        img.referrerPolicy = 'no-referrer';
        img.onerror = function() { this.style.visibility = 'hidden'; };

        var label = document.createElement('div');
        label.className = 'label';
        label.textContent = pair.actor;

        top.appendChild(img);
        top.appendChild(label);
        slot.appendChild(top);

        var assigned = document.createElement('div');
        assigned.className = 'assigned';
        assigned.textContent = assignments.get(pair.actor) || 'Tap a description to select, then tap here to assign — or drag a card onto this slot';
        slot.appendChild(assigned);

        // Click on slot to assign selected (tap-to-select flow)
        slot.addEventListener('click', (function(actorName) {
          return function() {
            if (!selectedDescId) {
              // no selection -> if already assigned, unassign on tap
              if (assignments.has(actorName)) {
                assignments.delete(actorName);
                showToast('Cleared selection for ' + actorName);
                renderDescriptions();
                renderSlots();
              }
              return;
            }
            var descIndex = parseInt(selectedDescId.split('-')[1], 10);
            var picked = shuffledDescs[descIndex];

            // Move this description from any other actor to this one
            var entries = Array.from(assignments.entries());
            for (var j = 0; j < entries.length; j++) {
              var a = entries[j][0];
              var d = entries[j][1];
              if (d === picked.description) assignments.delete(a);
            }
            assignments.set(actorName, picked.description);

            selectedDescId = null;
            renderDescriptions();
            renderSlots();
          };
        })(pair.actor));

        slotsEl.appendChild(slot);
      }
      // clear correctness styles on fresh render
      var allSlots = slotsEl.querySelectorAll('.slot');
      for (var k = 0; k < allSlots.length; k++) {
        allSlots[k].classList.remove('correct', 'incorrect', 'drop-target');
      }
    }

    function checkAnswers() {
      var total = PAIRS.length;
      if (assignments.size < total) {
        showToast('Assign all ' + total + ' descriptions before checking.');
        return;
      }
      var correctCount = 0;

      var allSlots = slotsEl.querySelectorAll('.slot');
      for (var i = 0; i < allSlots.length; i++) {
        var s = allSlots[i];
        var actor = s.dataset.actor;
        var expected = null;
        for (var j = 0; j < PAIRS.length; j++) {
          if (PAIRS[j].actor === actor) { expected = PAIRS[j].description; break; }
        }
        var got = assignments.get(actor);
        var isCorrect = expected === got;
        if (isCorrect) { s.classList.add('correct'); s.classList.remove('incorrect'); correctCount++; }
        else { s.classList.add('incorrect'); s.classList.remove('correct'); }
      }

      if (correctCount === total) {
        successMsg.style.display = 'block';
        hint.textContent = 'Perfect score! You matched every actor.';
        tryAgainBtn.style.display = 'none';
        showToast('Perfect! ' + correctCount + ' / ' + total + ' correct.');
      } else {
        successMsg.style.display = 'none';
        tryAgainBtn.style.display = 'inline-block';
        hint.textContent = 'Not quite—' + correctCount + ' of ' + total + ' correct. Tap “Try Again” to reshuffle descriptions and retry.';
        showToast(correctCount + ' of ' + total + ' correct. Try again!');
      }
    }

    function tryAgain() {
      assignments.clear();
      shuffledDescs = shuffle(PAIRS);
      successMsg.style.display = 'none';
      tryAgainBtn.style.display = 'none';
      hint.textContent = 'Try again: re-assign each description to the correct actor.';
      selectedDescId = null;
      renderDescriptions();
      renderSlots();
    }

    function resetGame() {
      selectedDescId = null;
      init();
      showToast('Game reset.');
    }

    function showToast(msg) {
      toast.textContent = msg;
      toast.classList.add('show');
      clearTimeout(showToast._t);
      showToast._t = setTimeout(function() { toast.classList.remove('show'); }, 1500);
    }

    // Helper: find slot under a point
    function findSlotAt(x, y) {
      var el = document.elementFromPoint(x, y);
      return el ? el.closest('.slot') : null;
    }

    // Touch/mouse friendly drag for a description card
    function attachDragHandlers(cardEl, descText) {
      var dragging = false;
      var ghost = null;
      var currentTarget = null;
      var startX = 0, startY = 0;

      function onPointerDown(e) {
        var p = getPoint(e);
        startX = p.x;
        startY = p.y;
        dragging = false;

        window.addEventListener('pointermove', onPointerMove, { passive: false });
        window.addEventListener('pointerup', onPointerUp, { passive: false });
      }

      function startDrag(x, y) {
        dragging = true;
        cardEl.setAttribute('aria-selected', 'false');

        ghost = cardEl.cloneNode(true);
        ghost.style.position = 'fixed';
        ghost.style.left = '0';
        ghost.style.top = '0';
        ghost.style.transform = 'translate(' + (x - 24) + 'px, ' + (y - 24) + 'px) scale(1.02)';
        ghost.style.pointerEvents = 'none';
        ghost.style.opacity = '0.95';
        ghost.style.zIndex = '9999';
        ghost.style.width = cardEl.getBoundingClientRect().width + 'px';
        ghost.classList.remove('assigned-card');
        document.body.appendChild(ghost);
      }

      function onPointerMove(e) {
        e.preventDefault();
        var p = getPoint(e);
        var x = p.x, y = p.y;

        if (!dragging && (Math.abs(x - startX) > 6 || Math.abs(y - startY) > 6)) {
          startDrag(x, y);
        }
        if (!dragging) return;

        ghost.style.transform = 'translate(' + (x - 24) + 'px, ' + (y - 24) + 'px) scale(1.02)';

        var slot = findSlotAt(x, y);
        if (currentTarget && currentTarget !== slot) {
          currentTarget.classList.remove('drop-target');
        }
        currentTarget = slot;
        if (currentTarget) {
          currentTarget.classList.add('drop-target');
        }
      }

      function onPointerUp(e) {
        window.removeEventListener('pointermove', onPointerMove);
        window.removeEventListener('pointerup', onPointerUp);

        var p = getPoint(e);
        var x = p.x, y = p.y;

        if (dragging) {
          if (currentTarget) {
            var actor = currentTarget.dataset.actor;

            // Move this description from any other actor to the new one
            var entries = Array.from(assignments.entries());
            for (var i = 0; i < entries.length; i++) {
              var a = entries[i][0];
              var d = entries[i][1];
              if (d === descText) assignments.delete(a);
            }
            assignments.set(actor, descText);

            selectedDescId = null;
            renderDescriptions();
            renderSlots();
          }

          if (currentTarget) currentTarget.classList.remove('drop-target');
          if (ghost) ghost.remove();
        } else {
          selectedDescId = (selectedDescId === cardEl.id) ? null : cardEl.id;
          updateSelectionStyles();
        }

        dragging = false;
        ghost = null;
        currentTarget = null;
      }

      cardEl.addEventListener('pointerdown', onPointerDown, { passive: false });
    }

    // wire up
    checkBtn.addEventListener('click', checkAnswers);
    tryAgainBtn.addEventListener('click', tryAgain);
    resetBtn.addEventListener('click', resetGame);

    // kick off
    init();
  </script>
</body>
</html>
